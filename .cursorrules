# Технический промт для микросервиса Campaign-API

## Описание микросервиса
Микросервис Campaign-API отвечает за создание, управление и запуск рекламных кампаний в Telegram. Основные функции сервиса:
1. Создание и управление кампаниями
2. Создание креативов (сообщений) для кампаний
3. Отправка данных о кампаниях в TdLib микросервис для их фактического выполнения через Telegram
4. Сбор и анализ статистики проведенных кампаний

## Технический стек
- Java 21
- Spring Boot 3.2.x
- Spring Data JPA
- PostgreSQL
- Spring Security
- Lombok, MapStruct
- Liquibase
- Swagger/OpenAPI
- JWT для авторизации

## Модель данных

### Основные сущности
1. **Campaign** - основная сущность кампании с полями:
   - UUID id - уникальный идентификатор
   - String title - название кампании
   - OffsetDateTime startDate - дата начала кампании
   - OffsetDateTime endDate - дата окончания кампании
   - OffsetDateTime createdAt - дата создания записи
   - UUID createdBy - идентификатор пользователя-создателя
   - CampaignType campaignType - тип кампании (AB_TEST, BROADCAST, IMMEDIATE)
   - CompanyStatus status - статус кампании (DRAFT, SCHEDULED, RUNNING, COMPLETED, FAILED, STOPPED)
   - UUID workspaceId - идентификатор рабочего пространства
   - UUID channelId - идентификатор канала
   - Boolean isArchived - признак архивации
   - Long maxRetargeted - максимальное количество ретаргетируемых пользователей

2. **CampaignCreative** - связь между кампанией и креативами:
   - UUID id - уникальный идентификатор
   - Message message - креатив (сообщение)
   - Campaign campaign - кампания
   - Integer percent - процентное распределение для А/B тестирования
   - Integer ordinal - порядковый номер креатива

3. **Message** - креатив (сообщение) для кампании:
   - UUID id - уникальный идентификатор
   - Boolean markDown - флаг использования markdown форматирования
   - UUID workspaceId - идентификатор рабочего пространства
   - String title - заголовок сообщения
   - MessageType type - тип сообщения
   - MessageStatus status - статус сообщения
   - Integer telegramId - идентификатор сообщения в Telegram
   - String text - текст сообщения
   - UUID createdBy - идентификатор создателя
   - UUID channelId - идентификатор канала
   - OffsetDateTime createdAt/updatedAt - даты создания/обновления
   - Set<Action> actions - кнопки/действия для сообщения
   - Set<Media> medias - медиафайлы, прикрепленные к сообщению

4. **Media** - медиафайлы (изображения, видео):
   - UUID id - уникальный идентификатор
   - Message message - связанное сообщение
   - UUID workspaceId - идентификатор рабочего пространства
   - UUID fileName - имя файла
   - String fileExtension - расширение файла

5. **Action** - кнопки/действия для интерактивных сообщений:
   - UUID id - уникальный идентификатор
   - Message message - связанное сообщение
   - String text - текст кнопки
   - String link - URL для перехода
   - Integer ordinal - порядковый номер кнопки

## Функциональные требования

### 1. Управление кампаниями (3 дня)
- Создание кампаний (с возможностью выбора немедленного запуска или отложенного)
- Получение списка кампаний с фильтрацией по каналу, статусу, архивации
- Получение детальной информации о кампании
- Остановка кампании
- Архивирование кампании
- Получение статистики по кампании

### 2. Управление креативами кампаний (2 дня)
- Создание креативов (сообщений) для кампаний
- Редактирование креативов
- Добавление медиафайлов к креативам
- Добавление кнопок (действий) к креативам
- Удаление креативов

### 3. Интеграция с TdLib сервисом (2 дня)
- Отправка данных о запущенных кампаниях в TdLib сервис
- Получение обратной связи о статусе отправки
- Обновление статусов кампаний на основе данных от TdLib

### 4. Аналитика и статистика (2 дня)
- Сбор базовой статистики по кампаниям
- Расчет эффективности A/B тестирования
- Предоставление API для получения аналитических данных

### 5. Безопасность и авторизация (1 день)
- Реализация проверок прав доступа на основе ролей
- Интеграция с системой JWT-авторизации
- Валидация входных данных

## API Endpoints

### Кампании
- `POST /campaigns/submit` - создание и запуск кампании
- `GET /campaigns` - получение списка кампаний с фильтрацией
- `GET /campaigns/{id}` - получение информации о конкретной кампании
- `POST /campaigns/{id}/stop` - остановка кампании
- `PATCH /campaigns/{id}/archive` - архивирование кампании
- `GET /campaigns/{id}/stats` - получение статистики по кампании
- `GET /campaigns/stats` - получение общей статистики по кампаниям
- `GET /campaigns/intervals` - получение интервалов дат кампаний
- `GET /campaigns/expected/retarget` - получение оценки числа подписчиков для ретаргетинга

### Конструктор креативов
- `POST /constructor` - создание креатива
- `GET /constructor/{id}` - получение креатива по ID
- `GET /constructor` - получение списка креативов
- `PUT /constructor/{id}` - обновление креатива
- `DELETE /constructor/{id}` - удаление креатива

### Медиафайлы
- `POST /media` - загрузка медиафайла
- `GET /media/{id}` - получение медиафайла

## Нефункциональные требования
1. **Производительность**:
   - Время отклика API не более 500 мс для основных операций
   - Оптимизация запросов к базе данных для работы с большими объемами данных

2. **Масштабируемость**:
   - Возможность горизонтального масштабирования сервиса
   - Эффективная работа с кэшированием

3. **Надежность**:
   - Правильная обработка транзакций
   - Логирование всех критических операций
   - Корректная обработка ошибок

4. **Безопасность**:
   - Защита от SQL-инъекций, XSS и других видов атак
   - Разграничение доступа на основе ролей

## Интеграции
1. **TdLib Микросервис**:
   - Отправка информации о кампаниях для исполнения через Telegram ботов
   - Получение статусов выполнения

2. **Workspace Микросервис**:
   - Получение информации о рабочих пространствах и правах доступа

## Критерии приемки
1. API полностью документировано через Swagger/OpenAPI
2. Все эндпоинты покрыты модульными и интеграционными тестами
3. Логирование настроено на всех уровнях приложения
4. Успешная интеграция с TdLib сервисом
5. Корректная работа с различными типами кампаний и креативов

## Стиль и структура кода
- Строгое соблюдение принципа разделения ответственности (слои Controller, Service, Repository)
- Использование DTO для передачи данных между слоями
- Следование конвенциям наименования Spring Boot
- Применение конструкторной инъекции зависимостей
- Использование иммутабельных объектов, где это возможно
- Четкая документация кода с использованием Javadoc

## Технические особенности
- Использование Liquibase для миграций базы данных
- Настройка Swagger для автоматического создания документации API
- Применение принципов HATEOAS для RESTful API
- Настройка асинхронных операций для длительных задач 