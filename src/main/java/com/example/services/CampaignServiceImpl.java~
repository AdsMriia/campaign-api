package org.example.service.impl;

import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.example.entity.enums.CampaignType;
import org.example.entity.enums.CompanyStatus;
import org.example.entity.enums.ErrorMessage;
import org.example.entity.enums.MessageStatus;
import org.example.entity.subscriber.*;
import org.example.entity.subscriber.dto.*;
import org.example.exception.*;
import org.example.mapper.CompanyMapper;
import org.example.repository.*;
import org.example.security.UserProvider;
import org.example.service.CampaignService;
import org.example.service.WebUserService;
import org.example.util.Util;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.task.TaskExecutor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * Service implementation for managing campaign operations.
 * <p>
 * This service provides functionality for managing and retargeting campaigns,
 * retrieving campaign statistics, and submitting campaigns.
 */
@Service
@RequiredArgsConstructor
@Transactional
public class CampaignServiceImpl implements CampaignService {
    private final MessageRepository messageRepository;
    private final ActionRepository actionRepository;
    private final MediaRepository mediaRepository;
    private final CampaignRepository campaignRepository;
    private final ABMessageRepository abMessageRepository;
    private final ChannelWorkspaceRepository channelWorkspaceRepository;
    private final RetargetStatsRepository retargetStatsRepository;
    private final CampaignToSubscribersRepository campaignToSubscribersRepository;
    private final ChannelSubscriberRepository channelSubscriberRepository;

    private final ChannelRepository channelRepository;

    private final UserProvider userProvider;
    private final WebUserService webUserService;

    private final CompanyMapper companyMapper;

    private final TaskExecutor taskExecutor;
    private final TransactionTemplate transactionTemplate;
    private final RestTemplate restTemplate;

    private final Logger LOGGER = LoggerFactory.getLogger(CampaignServiceImpl.class);
    private final BalanceRepository balanceRepository;

    @Override
    public Optional<String> retarget(UUID channelId, Long timestamp, UUID abTableId, String timezone) {
        String url = "http://tdbot:8090/api/initialize/cycle?channelId=" + channelId + "&timestamp=" + timestamp + "&campaignId=" + abTableId + "&timezone=" + timezone;
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-Request-Timeout", "10000");

        HttpEntity<String> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response;
        try {
            response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
        } catch (Exception e) {
            String message = e.getMessage();
            LOGGER.error("Error while connecting to Telegram API: {}. Exception: {}", message, e);
            return Optional.of(HttpStatus.SERVICE_UNAVAILABLE.getReasonPhrase());
        }
        LOGGER.info("Response status: {}", response.getStatusCode());
        if (response.getStatusCode() == HttpStatus.OK) {
            return Optional.empty();
        } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {
            return Optional.of("not found");
        } else if (response.getStatusCode() == HttpStatus.INTERNAL_SERVER_ERROR) {
            return Optional.of("Sending Service is not available");
        }
        return Optional.of("Unknown error: " + response.getStatusCode());
    }


    /**
     * Извлекает статистику для данной кампании, идентифицированной предоставленным UUID.
     *
     * @param abTableId уникальный идентификатор кампании
     * @return объект RetargetStatsDto, содержащий статистику для указанной кампании
     */
    @Override
    public RetargetStatsDto getStats(UUID abTableId) {
        RetargetStatsDto retargetStatsDto = new RetargetStatsDto();
        Campaign campaign = campaignRepository.findById(abTableId).orElseThrow(() -> new NotFoundException("Campaign not found"));
        List<RetargetStats> retargetStatsList = retargetStatsRepository.findAllByCampaignId(abTableId);
        Optional<RetargetStats> retargetStatsOptional = retargetStatsList.stream()
                .sorted(Comparator.comparing(RetargetStats::getCreatedAt).reversed())
                .findFirst();

        if (retargetStatsOptional.isEmpty()) {
            return retargetStatsDto;
        }

        mapToRetargetStatsDtos(retargetStatsOptional.get(), campaign);
        return retargetStatsDto;
    }

    /*
     * Останавливает ретаргетинг по идентификатору таблицы AB.
     */
    @Override
    public boolean stopRetarget(UUID abTableId) {
        String url = "http://tdbot:8090/api/retarget/stop?campaignId=" + abTableId;
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-Request-Timeout", "10000");

        HttpEntity<String> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response;
        try {
            response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
        } catch (Exception e) {
            LOGGER.error("Error stopping retargeting: {}. Exception: {}", e.getMessage(), e);
            throw new ServiceUnavailableException();
        }
        LOGGER.info("Response status: {}", response.getStatusCode());
        if (response.getStatusCode() != HttpStatus.OK) {
            throw new RequestRejectedException(response.getBody());
        }
        return true;
    }

    @Override
    public Page<CampaignDto> getAll(List<UUID> channelIds, Integer page, CompanyStatus status, Integer size, Boolean asc, String sort, Boolean isArchived) {
        LOGGER.debug("Parameters received - channelId: {}, page: {}, status: {}, size: {}, asc: {}, sort: {}, isArchived: {}",
                channelIds, page, status, size, asc, sort, isArchived);
        Workspace workspace = webUserService.getWorkspace();

        if (size == 0) {
            size = campaignRepository.findAllByWorkspace(workspace).size();
            if (size == 0) {
                size = 10;
            }
        }

        Specification<Campaign> specification = Specification.where(null);

        if (channelIds != null && !channelIds.isEmpty()) {
            channelIds = Util.getChannelIdsFromWorkspaces(channelWorkspaceRepository, channelIds);
            List<UUID> finalChannelIds = channelIds;
            specification = specification.and((root, query, cb) -> root.join("channel").get("id").in(finalChannelIds));
        }
        if (status != null) {
            specification = specification.and((root, query, cb) -> cb.equal(root.get("status"), status));
        }
        if (isArchived != null) {
            specification = specification.and((root, query, cb) -> cb.equal(root.get("isArchived"), isArchived));
        }

        specification = specification.and((root, query, cb) -> cb.equal(root.get("workspace"), workspace));

        PageRequest pageRequest = PageRequest.of(
                page,
                size,
                asc ? Sort.by(Sort.Order.asc(sort)) : Sort.by(Sort.Order.desc(sort))
        );

        Page<Campaign> campaigns = campaignRepository.findAll(specification, pageRequest);

        return campaigns.map(companyMapper::mapToDto);
    }

    @Override
    public CampaignDto getByCampaignId(UUID campaignId) {
        Optional<Campaign> optionalABTable = campaignRepository.findById(campaignId);
        if (optionalABTable.isEmpty()) {
            throw new NotFoundException(ErrorMessage.DATA_NOT_FOUND);
        }
        return companyMapper.mapToDto(optionalABTable.get());
    }

    /**
     * Отправляет A/B тестовое сообщение в указанные каналы.
     *
     * @param submitABDto объект DTO, содержащий детали A/B теста
     * @return список ABTableDto с подробностями отправленных A/B тестов
     * @throws NoSelectedChannel        если не выбраны каналы
     * @throws NoButtonException        если не предоставлены сообщения
     * @throws RequestRejectedException если значения процентов некорректны
     * @throws NotFoundException        если ABTable не найден после сохранения
     */
    @Override
    public List<CampaignDto> campaignBasicSubmit(SubmitABDto submitABDto, String timeZone) {
        // Валидация входных данных
        validateSubmitABDto(submitABDto);

        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Workspace workspace = webUserService.getWorkspace();

        WebUser webUser = userProvider.getCurrentUser();

        CompletableFuture<List<CampaignDto>> future = new CompletableFuture<>();

        OffsetDateTime now = OffsetDateTime.now(ZoneOffset.UTC);

        executorService.submit(() -> {

            transactionTemplate.execute(status -> {
                try {

                    for (UUID channelId : submitABDto.getChannelIds()) {
                        ChannelWorkspace channelWorkspace = channelWorkspaceRepository.findById(channelId)
                                .orElseThrow(() -> new NotFoundException(ErrorMessage.CHANNEL_NOT_FOUND, channelId));
                    }

                    // Обработка каждого канала
                    List<CampaignDto> abTableList = new ArrayList<>();
                    for (UUID channelId : submitABDto.getChannelIds()) {

                        CampaignDto abTableDto = processChannel(channelId, submitABDto, workspace, webUser, now, timeZone);
                        if (abTableDto != null) {
                            abTableList.add(abTableDto);
                        }
                    }
                    future.complete(abTableList);
                } catch (Exception e) {
                    status.setRollbackOnly();
                    future.completeExceptionally(e);
                }
                return null;
            });
        });
        List<CampaignDto> abTableDtoList;
        try {
            abTableDtoList = future.get();
        } catch (Exception e) {
            System.out.println(e.getStackTrace());
            throw new RuntimeException(e);
        }
//        executorService.shutdown();
        for (CampaignDto campaignDto : abTableDtoList) {
            retarget(campaignDto.getChannelId(), submitABDto.getStartDate(), campaignDto.getId(), timeZone);
        }
        return abTableDtoList;
    }

    /**
     * Триггер для немедленной отправки каналам через Telegram.
     *
     * @param submitABDto объект {@link SubmitABDto}, содержащий данные для немедленной отправки сообщения.
     * @return true, если сообщение отправлено успешно; иначе false.
     */
    @Override
    public List<CampaignDto> immediateSubmit(SubmitABDto submitABDto) {
        Workspace workspace = webUserService.getWorkspace();
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture<List<Campaign>> future = new CompletableFuture<>();

        WebUser webUser = userProvider.getCurrentUser();

        executorService.submit(() -> {

            transactionTemplate.execute(status -> {
                try {
                    List<Campaign> immediateCampaigns = new ArrayList<>();
                    for (UUID channelWorkspaceId : submitABDto.getChannelIds()) {
                        Campaign immediateCampaign = new Campaign();
                        Optional<ChannelWorkspace> optionalChannelWorkspace = channelWorkspaceRepository.findById(channelWorkspaceId);
                        if (optionalChannelWorkspace.isEmpty()) {
                            continue;
                        }
                        immediateCampaign.setTitle(submitABDto.getTitle());
                        immediateCampaign.setStatus(CompanyStatus.SENDING);
                        immediateCampaign.setWorkspace(workspace);
                        immediateCampaign.setCreatedBy(webUser);
                        immediateCampaign.setCampaignType(CampaignType.IMMEDIATE);
                        OffsetDateTime now = OffsetDateTime.now();
                        immediateCampaign.setCreatedAt(now);
                        immediateCampaign.setStartDate(now);
                        immediateCampaign.setChannel(channelRepository.findById(
                                        optionalChannelWorkspace.get().getChannelId())
                                .orElseThrow(() -> new NotFoundException(ErrorMessage.DATA_NOT_FOUND)));
                        immediateCampaign.setCampaignCreatives(new HashSet<>());

                        List<ExpectedRetargetDto> expectedRetargetDtos = getExpectedRetargetDtos(webUser, List.of(optionalChannelWorkspace.get()));

                        Double reducePercent = submitABDto.getAudiencePercent() / 100.0;

                        long maxRetargeted = (long) Math.floor(expectedRetargetDtos.get(0).getExpectedRetarget() * reducePercent);
                        immediateCampaign.setMaxRetargeted(maxRetargeted);
                        immediateCampaign.setCampaignCreatives(new HashSet<>());

                        // save ABTable for getting ID
                        campaignRepository.save(immediateCampaign);

                        // Обработка каждого сообщения и связывание его с ABTable
                        for (SubmitMessageDto submitMessageDto : submitABDto.getMessages()) {
                            CampaignCreative immediateCreative = processMessage(submitMessageDto, immediateCampaign);
                            if (immediateCreative != null) {
                                immediateCreative.setOrdinal(submitABDto.getMessages().indexOf(submitMessageDto));
                                immediateCampaign.getCampaignCreatives().add(immediateCreative);
                            }
                            // Получение сохраненного ABTable для проверки его существования
                        }
                        immediateCampaigns.add(immediateCampaign);
                    }
                    future.complete(immediateCampaigns);
                } catch (Exception e) {
                    status.setRollbackOnly();
                    future.completeExceptionally(e);
                }
                return null;
            });
        });
        List<Campaign> immediateCampaigns = new ArrayList<>();
        try {
            immediateCampaigns = future.get();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        List<CampaignDto> campaignDtos = campaignMapToDto(immediateCampaigns);

        List<Campaign> finalImmediateCampaigns = immediateCampaigns;
        taskExecutor.execute(() -> {
            try {
                Thread.sleep(1000); // Задержка для завершения транзакции
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            for (Campaign immediateCampaign : finalImmediateCampaigns) {
                sendImmediate(immediateCampaign.getId());
                immediateCampaign.setStatus(CompanyStatus.ANALYZING);
                immediateCampaign.setEndDate(immediateCampaign.getStartDate().plusDays(2));
                campaignRepository.save(immediateCampaign);
            }

        });
        return campaignDtos;
    }

    /**
     * Преобразует список объектов {@link ImmediateCampaign} в список объектов {@link ImmediateCampaignDto}.
     * Отображает свойства каждого {@link ImmediateCampaign} и связанного с ним {@link ImmediateCreative}
     * на соответствующие поля в {@link ImmediateCampaignDto} и {@link ImmediateCampaignCreativeDto}.
     *
     * @param immediateCampaigns список сущностей {@link ImmediateCampaign}, которые нужно преобразовать.
     * @return список объектов {@link ImmediateCampaignDto}, представляющих преобразованные кампании.
     */
    private List<CampaignDto> campaignMapToDto(List<Campaign> immediateCampaigns) {
        return immediateCampaigns.stream().map(immediateCampaign -> {
            CampaignDto immediateCampaignDto = new CampaignDto();
            immediateCampaignDto.setId(immediateCampaign.getId());
            immediateCampaignDto.setTitle(immediateCampaign.getTitle());
            immediateCampaignDto.setChannelId(immediateCampaign.getChannel().getId());
            immediateCampaignDto.setCreatedAt(immediateCampaign.getCreatedAt().toEpochSecond());
            immediateCampaignDto.setStatus(immediateCampaign.getStatus());
            immediateCampaignDto.setCreatedBy(immediateCampaign.getCreatedBy().getUsername());
            immediateCampaignDto.setIsArchived(immediateCampaign.getIsArchived());

            List<CampaignCreativeDto> creativeDtoList = immediateCampaign.getCampaignCreatives().stream().map(immediateCreative -> {
                CampaignCreativeDto immediateCampaignCreativeDto = new CampaignCreativeDto();
                immediateCampaignCreativeDto.setAbTableId(immediateCampaign.getId());
                immediateCampaignCreativeDto.setText(immediateCreative.getMessage().getText());
                immediateCampaignCreativeDto.setPercent(immediateCreative.getPercent());
                immediateCampaignCreativeDto.setMessageId(immediateCreative.getMessage().getId());
                return immediateCampaignCreativeDto;
            }).collect(Collectors.toList());

            immediateCampaignDto.setCampaignCreativeDto(creativeDtoList);

            return immediateCampaignDto;
        }).collect(Collectors.toList());
    }

//    /**
//     * Обрабатывает сообщение и связывает его с кампанией.
//     *
//     * @param submitMessageDto объект {@link SubmitMessageDto}, содержащий данные сообщения для обработки.
//     * @param immediateCampaign объект {@link ImmediateCampaign}, представляющий кампанию, с которой связано сообщение.
//     * @return объект {@link ImmediateCreative}, представляющий обработанное сообщение и его привязку к кампании,
//     *         или null, если сообщение не найдено.
//     */
//    private ImmediateCreative processMessage(SubmitMessageDto submitMessageDto, ImmediateCampaign immediateCampaign) {
//        ImmediateCreative immediateCreative = new ImmediateCreative();
//        immediateCreative.setImmediateCampaign(immediateCampaign);
//        immediateCreative.setPercent(submitMessageDto.getPercent());
//
//        Optional<Message> optionalMessage = messageRepository.findById(submitMessageDto.getMessageId());
//        if (optionalMessage.isEmpty()) {
//            return null;
//        }
//
//        // Клонирование сообщения для избежания изменений оригинала
//        Message message = optionalMessage.get();
//        message = message.clone();
//
//        // Извлечение действий и медиа, затем очистка в сообщении
//        Set<Action> actions = message.getActions();
//        Set<Media> medias = message.getMedias();
//        message.setActions(new HashSet<>());
//        message.setMedias(new HashSet<>());
//
//        message.setStatus(MessageStatus.ACTIVE);
//        message = messageRepository.save(message);
//
//        // Связывание действий с новым сообщением
//        Message finalMessage = message; // Эффективно финальная переменная для использования в лямбда-выражении
//        actions.forEach(action -> action.setObjectPool(finalMessage));
//        medias.forEach(media -> media.setObjectPool(finalMessage));
//
//        actionRepository.saveAll(actions);
//        mediaRepository.saveAll(medias);
//        // Установка сообщения в ImmediateCreative
//        immediateCreative.setMessage(message);
//
//        immediateCreativeRepository.save(immediateCreative);
//
//        return immediateCreative;
//    }

    public Boolean sendImmediate(UUID immediateCampaignId) {
        String url = "http://tdbot:8090/api/send/immediate?campaignId=" + immediateCampaignId;
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        headers.set("X-Request-Timeout", "10000");

        HttpEntity<String> request = new HttpEntity<>(headers);
        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
            if (response.getStatusCode() == HttpStatus.OK) {
                return true;
            } else if (response.getStatusCode() == HttpStatus.NOT_FOUND) {
                throw new NotFoundException(ErrorMessage.DATA_NOT_FOUND, response.getBody());
            } else {
                return false;
            }
        } catch (Exception e) {
            String message = e.getMessage();
            LOGGER.error("Error while sending POST request to Telegram API: {}", message);
            throw new RuntimeException("Send immediate temporary unavailable");
        }
    }

    /**
     * Архивирует кампанию, идентифицированную предоставленным UUID. Этот метод выбросит
     * исключение RequestRejectedException, если кампания уже архивирована или если ее статус
     * является PENDING или ACTIVE.
     *
     * @param campaignId UUID кампании, которую нужно архивировать
     * @return CampaignDto, представляющий архивированную кампанию
     * @throws NotFoundException        если кампания с предоставленным UUID не найдена
     * @throws RequestRejectedException если кампания уже архивирована или ее статус запрещает архивирование
     */
    @Override
    public CampaignDto archiveCampaign(UUID campaignId) {
        Campaign campaign = campaignRepository.findById(campaignId)
                .orElseThrow(() -> new NotFoundException(ErrorMessage.DATA_NOT_FOUND));
        if (campaign.getIsArchived()) {
            throw new RequestRejectedException("Already archived");
        }
        if (campaign.getStatus() == CompanyStatus.PENDING || campaign.getStatus() == CompanyStatus.ACTIVE) {
            throw new RequestRejectedException("Cannot archive with status " + campaign.getStatus());
        }
        campaign.setIsArchived(true);
        campaignRepository.save(campaign);
        return companyMapper.mapToDto(campaign);
    }

    /**
     * Извлекает список объектов ChannelCampaignDatesDto, каждый из которых содержит информацию
     * о промежутках времени кампаний для различных каналов, связанных с текущим рабочим пространством.
     *
     * @return список объектов ChannelCampaignDatesDto, содержащих данные о промежутках времени кампаний.
     */
    @Override
    public List<ChannelCampaignDatesDto> getCampaignIntervalDate(List<UUID> channelIdList) {
        Workspace workspace = webUserService.getWorkspace();
        List<ChannelCampaignDatesDto> channelCampaignDatesDtoList = new ArrayList<>();
        for (UUID channelId : channelIdList) {
            ChannelWorkspace channelWorkspace = channelWorkspaceRepository.findById(channelId).orElseThrow(() -> new NotFoundException(ErrorMessage.CHANNEL_NOT_FOUND));
            if (channelWorkspace.getWorkspaceId() != workspace.getId()) {
                throw new NotFoundException(ErrorMessage.CHANNEL_NOT_FOUND);
            }
            if (!channelWorkspace.isTracking()) {
                throw new NotFoundException(ErrorMessage.CHANNEL_NOT_TRACKING);
            }
            List<Campaign> campaigns = campaignRepository.findAllByChannel(
                    channelRepository.findById(channelWorkspace.getChannelId())
                            .orElseThrow(() -> new NotFoundException(ErrorMessage.DATA_NOT_FOUND)));
            ChannelCampaignDatesDto channelCampaignDatesDto = new ChannelCampaignDatesDto();
            channelCampaignDatesDto.setCampaignDates(new ArrayList<>());
            channelCampaignDatesDto.setChannelId(channelWorkspace.getId());
            for (Campaign campaign : campaigns) {
                if (campaign.getStatus() != CompanyStatus.ACTIVE && campaign.getStatus() != CompanyStatus.PENDING) {
                    continue;
                }
                CampaignDateDto campaignDateDto = new CampaignDateDto();
                campaignDateDto.setEnd(campaign.getEndDate().toEpochSecond());
                campaignDateDto.setStart(campaign.getStartDate().toEpochSecond());
                channelCampaignDatesDto.getCampaignDates().add(campaignDateDto);
            }
            channelCampaignDatesDtoList.add(channelCampaignDatesDto);
        }
        return channelCampaignDatesDtoList;
    }


    /**
     * Извлекает постраничный список статистики ретаргетинга для текущего рабочего пространства.
     * <p>
     * Этот метод собирает статистику ретаргетинга, отсортированную и распределенную по страницам в соответствии с переданными параметрами,
     * для кампаний, связанных с рабочим пространством текущего веб-пользователя.
     *
     * @param page номер страницы для извлечения
     * @param size количество записей на странице
     * @param asc  флаг, указывающий на то, что сортировка должна быть по возрастанию (true) или по убыванию (false)
     * @param sort имя поля, по которому следует сортировать результаты
     * @return постраничный список объектов RetargetStatsDto
     */
    @Override
    public Page<RetargetStatsDto> getAllStats(Integer page, Integer size, Boolean asc, String sort, Long startDate, Long endDate, List<UUID> channelWorkspaceId) {
        LOGGER.debug("Parameters received - page: {}, size: {}, asc: {}, sort: {}", page, size, asc, sort);
        Workspace workspace = webUserService.getWorkspace();

        if (size == 0) {
            size = retargetStatsRepository.countAllByWorkspace(workspace).intValue();
            if (size == 0) {
                size = 10;
            }
        }

        PageRequest pageRequest = PageRequest.of(
                page,
                size,
                asc ? Sort.by(Sort.Order.asc(sort)) : Sort.by(Sort.Order.desc(sort))
        );

        Specification<RetargetStats> spec = Specification.where(null);
        spec.and((root, query, cb) -> cb.equal(root.join("campaign").get("workspace"), workspace));
        if (channelWorkspaceId != null && !channelWorkspaceId.isEmpty()) {
            List<UUID> validChannelIds = Util.getChannelIdsFromWorkspaces(channelWorkspaceRepository, channelWorkspaceId);
            spec = spec.and((root, query, cb) ->
                    root.join("campaign").join("channel").get("id").in(validChannelIds));
        }

        // Додаємо підзапит для вибору найновішого запису для кожної кампанії
//        spec = spec.and((root, query, cb) -> {
//            Subquery<OffsetDateTime> subquery = query.subquery(OffsetDateTime.class);
//            Root<RetargetStats> subRoot = subquery.from(RetargetStats.class);
//
//            // Знаходимо максимальний createdAt для кожної кампанії
//            subquery.select(cb.greatest(subRoot.get("createdAt")))
//                    .where(cb.equal(subRoot.get("campaign").get("id"), root.get("campaign").get("id")));
//
//            // Основний запит повертає лише ті записи, що відповідають максимальному createdAt
//            return cb.equal(root.get("createdAt"), subquery);
//        });
        if (startDate != null && endDate != null) {
            if (startDate > endDate) {
                throw new IllegalArgumentException("The 'startDate' must be less than or equal to the 'endDate'");
            }
            OffsetDateTime startDateTime = Util.timestampToOffset(startDate);
            OffsetDateTime endDateTime = Util.timestampToOffset(endDate);
            spec = spec.and((root, query, cb) -> cb.between(root.join("campaign").get("createdAt"), startDateTime, endDateTime));
        } else if (!(startDate == null && endDate == null)) {
            throw new IllegalArgumentException("Both 'startDate' and 'endDate' must be provided, or neither of them");
        }
        Page<RetargetStats> campaignPage = retargetStatsRepository.findAll(spec, pageRequest);
        return campaignPage.map(rs -> mapToRetargetStatsDtos(rs, rs.getCampaign()));
    }


    /**
     * Вычисляет максимальное количество подписок для заданного списка идентификаторов каналов
     * и генерирует список объектов ExpectedRetargetDto на основе данных текущего пользователя и связанных каналов.
     *
     * @param channelsId список UUID, представляющих идентификаторы каналов
     * @return список объектов ExpectedRetargetDto, содержащих информацию о вычисленных подписках
     */
    @Override
    public List<ExpectedRetargetDto> maxSubCount(List<UUID> channelsId) {
        if (channelsId == null || channelsId.isEmpty()) {
            throw new IllegalArgumentException("Список идентификаторов каналов не может быть пустым");
        }

        List<ChannelWorkspace> channelWorkspaces = channelWorkspaceRepository.findAllById(channelsId);

        if (channelWorkspaces.isEmpty()) {
            throw new NotFoundException("Каналы с указанными идентификаторами не найдены");
        }

        WebUser webUser = userProvider.getCurrentUser();
        return getExpectedRetargetDtos(webUser, channelWorkspaces);
    }

    @Override
    public List<CampaignDto> getAllCampaign(List<UUID> workspaceIds) {

        List<CampaignDto> campaignDtoList = new ArrayList<>();
        List<Campaign> campaignDtos = campaignRepository.findAllByWorkspaceId(workspaceIds);
        for (Campaign campaignDto : campaignDtos) {
            CampaignDto campDto = new CampaignDto();
            campDto.setId(campaignDto.getId());
            campDto.setTitle(campaignDto.getTitle());
            campDto.setChannelId(campaignDto.getChannel().getId());
            campDto.setCreatedAt(campaignDto.getCreatedAt().toEpochSecond());
            campDto.setStatus(campaignDto.getStatus());
            campDto.setCreatedBy(campaignDto.getCreatedBy().getUsername());
            campDto.setIsArchived(campaignDto.getIsArchived());
            campDto.setChannelTitle(campaignDto.getChannel().getTitle());
            campDto.setStartDate(campaignDto.getStartDate().toEpochSecond());
            campDto.setEndDate(campaignDto.getEndDate().toEpochSecond());
            campDto.setCreatedBy(campaignDto.getCreatedBy().getUsername());

            List<CampaignCreativeDto> creativeDtoList = new ArrayList<>();
            for (CampaignCreativeDto campaignCreativeDto : creativeDtoList) {
                campaignCreativeDto.setText(campaignCreativeDto.getText());
                campaignCreativeDto.setPercent(campaignCreativeDto.getPercent());
                campaignCreativeDto.setMessageId(campaignCreativeDto.getMessageId());
                campaignCreativeDto.setAbTableId(campaignDto.getId());
            }
            campDto.setCampaignCreativeDto(creativeDtoList);

            campaignDtoList.add(campDto);

        }

        return campaignDtoList;
    }

    /**
     * Генерирует список объектов ExpectedRetargetDto на основе баланса пользователя,
     * рабочих пространств каналов, и встроенного начального списка объектов ExpectedRetargetDto.
     *
     * @param webUser           пользователь, для которого генерируется информация о ретаргетинге
     * @param channelWorkspaces список рабочих пространств каналов для расчета данных ретаргетинга
     * @return список объектов ExpectedRetargetDto с информацией о ретаргете и бюджете для каждого рабочего пространства канала
     */
    public List<ExpectedRetargetDto> getExpectedRetargetDtos(WebUser webUser, List<ChannelWorkspace> channelWorkspaces) {
        Optional<Balance> optionalBalance = balanceRepository.findByUser(webUser);
        BigDecimal balanceAmount = optionalBalance.map(Balance::getAmount).orElse(BigDecimal.ZERO);

        BigDecimal expectedSub = balanceAmount.divide(new BigDecimal("3.5"), RoundingMode.DOWN);

        List<ExpectedRetargetDto> expectedRetargetDtos = new ArrayList<>();

        for (ChannelWorkspace channelWorkspace : channelWorkspaces) {

            Channel channel = channelRepository.findById(channelWorkspace.getChannelId())
                    .orElseThrow(() -> new NotFoundException(ErrorMessage.DATA_NOT_FOUND));

            Integer count = channelSubscriberRepository.findAllByChannel(channel).size();
            ExpectedRetargetDto expectedRetargetDto = new ExpectedRetargetDto();

            expectedRetargetDto.setExpectedRetarget(Math.min(expectedSub.longValue(), count));
            expectedRetargetDto.setChannelId(channelWorkspace.getId());
            expectedRetargetDto.setChannelTitle(channel.getTitle());
            expectedRetargetDto.setExpectedBudget(BigDecimal.valueOf(expectedRetargetDto.getExpectedRetarget()).multiply(new BigDecimal("3.5")));
            expectedRetargetDtos.add(expectedRetargetDto);
        }

        return expectedRetargetDtos;
    }


    /**
     * Преобразует объект RetargetStats в объект RetargetStatsDto.
     * <p>
     * Этот метод вычисляет CTR (Click-Through Rate) кампании на основе количества ретаргетированных и отправленных сообщений.
     * Затем он собирает информацию о сообщениях ретаргетинга для данной кампании и возвращает эту информацию в виде объекта RetargetStatsDto.
     *
     * @param retargetStats объект, содержащий статистику ретаргетинга
     * @param campaign      объект, содержащий информацию о кампании
     * @return объект RetargetStatsDto с данными о статистике ретаргетинга
     */
    private RetargetStatsDto mapToRetargetStatsDtos(RetargetStats retargetStats, Campaign campaign) {
        double ctr = (retargetStats.getRetargetCount() == 0) ? 0.0
                : ((double) retargetStats.getRetargetCount()
                / retargetStats.getSentMessageCount()) * 100.0;

        ctr = Math.round(ctr * 100.0) / 100.0;
        RetargetStatsDto retargetStatsDto = new RetargetStatsDto();

        retargetStatsDto.setCtr(ctr);
        retargetStatsDto.setChannelId(retargetStats.getCampaign().getChannel().getId());
        retargetStatsDto.setChannelTitle(retargetStats.getCampaign().getChannel().getTitle());
        retargetStatsDto.setTitle(retargetStats.getCampaign().getTitle());
        retargetStatsDto.setRetargetCount(retargetStats.getRetargetCount());
        if (campaign.getCreatedBy() != null) {
            retargetStatsDto.setCreatedBy(campaign.getCreatedBy().getUsername());
        }
        retargetStatsDto.setCreatedAt(retargetStats.getCreatedAt().toEpochSecond());
        retargetStatsDto.setStartDate(campaign.getStartDate().toEpochSecond());
        retargetStatsDto.setEndDate(campaign.getEndDate().toEpochSecond());
//        retargetStatsDto.setParticipantCount(retargetStats.getParticipantCount());
        retargetStatsDto.setSentMessageCount(retargetStats.getSentMessageCount());

        Map<CampaignCreative, Long> abMessageCountMap = campaignToSubscribersRepository.findAllByCampaign(campaign.getId()).stream()
                .filter(item -> Boolean.TRUE.equals(item.getRetargeted()))
                .collect(Collectors.groupingBy(
                        CampaignToSubscribers::getCampaignCreative,
                        Collectors.counting()
                ));
        Map<CampaignCreative, Long> abMessageLongMap = campaignToSubscribersRepository.findAllByCampaign(campaign.getId()).stream()
                .collect(Collectors.groupingBy(
                        CampaignToSubscribers::getCampaignCreative,
                        Collectors.counting()
                ));
        Set<RetargetMessageDto> retargetMessageDtos = new HashSet<>();

        Integer percent = 0;
        for (CampaignCreative campaignCreative : abMessageLongMap.keySet()) {
            RetargetMessageDto retargetMessageDto = new RetargetMessageDto();
            retargetMessageDto.setTitle(campaignCreative.getMessage().getTitle());
            retargetMessageDto.setPercent(campaignCreative.getPercent());
            retargetMessageDto.setRetarget(abMessageCountMap.get(campaignCreative));
            retargetMessageDto.setSent(abMessageLongMap.get(campaignCreative));
            retargetMessageDto.setMessageId(campaignCreative.getMessage().getId());
            retargetMessageDtos.add(retargetMessageDto);
            percent += campaignCreative.getPercent();
        }

        retargetStatsDto.setPercent(percent);
        retargetStatsDto.setRetargetMessageDto(retargetMessageDtos);
        return retargetStatsDto;
    }


    /**
     * Валидирует объект SubmitABDto, чтобы гарантировать, что его свойства соответствуют определенным критериям.
     * Дата начала должна быть в секундах и не превышать 10 символов.
     * Процент каждого сообщения должен быть от 0 до 100, кратным 5,
     * а сумма всех процентов сообщений не должна превышать 100.
     *
     * @param submitABDto Объект SubmitABDto, содержащий детали A/B-теста для валидации.
     * @throws RequestRejectedException если дата начала не в секундах,
     *                                  если какой-либо процент сообщения выходит за допустимый диапазон (1-100),
     *                                  если процент не кратен 5,
     *                                  или если общий процент превышает 100.
     */
    private void validateSubmitABDto(SubmitABDto submitABDto) {
        if (String.valueOf(submitABDto.getStartDate()).length() > 10) {
            throw new RequestRejectedException("Date must be in seconds");
        }

        // check if percent values are valid
        int percent = 0;
        for (SubmitMessageDto submitMessageDto : submitABDto.getMessages()) {
            if (submitMessageDto.getPercent() <= 0 || submitMessageDto.getPercent() > 100) {
                throw new RequestRejectedException("Percent must be between 0 and 100");
            }
            if (submitMessageDto.getPercent() % 5 != 0) {
                throw new RequestRejectedException("Percent must be a multiple of 5");
            }
            percent += submitMessageDto.getPercent();
        }

        if (percent > 100) {
            throw new RequestRejectedException("Sum of percents must be less than or equal to 100");
        }
    }

    /**
     * Обрабатывает канал для подачи кампании, валидируя диапазон дат и обрабатывая сообщения.
     * Этот метод получает связанный канал по его идентификатору, валидирует даты кампании,
     * и сохраняет кампанию и связанные с ней сообщения.
     *
     * @param channelId   уникальный идентификатор обрабатываемого канала
     * @param submitABDto объект передачи данных, содержащий детали A/B-теста
     * @param workspace   рабочее пространство, связанное с кампанией
     * @param now         текущая метка времени, используемая для валидации
     * @return CampaignDto, содержащий детали обработанной кампании, или null, если канал не существует
     * @throws RequestRejectedException если дата начала в прошлом, если дата начала позже даты окончания,
     *                                  или если есть пересечение дат с существующими кампаниями
     * @throws NotFoundException        если кампания не может быть найдена после сохранения
     */
    private CampaignDto processChannel(UUID channelId, SubmitABDto submitABDto, Workspace workspace, WebUser webUser, OffsetDateTime now, String timeZone) {
        Optional<ChannelWorkspace> optionalChannelPool = channelWorkspaceRepository.findById(channelId);
        if (optionalChannelPool.isEmpty()) {
            // Если канал не существует, пропускаем обработку
            return null;
        }
//        System.out.println(abTable.getStartDate());
        OffsetDateTime tableStartTime = Util.timestampToOffset(submitABDto.getStartDate(), timeZone);
        tableStartTime = tableStartTime.withHour(0).withMinute(0).withSecond(0).withNano(0);

        OffsetDateTime tableEndTime = Util.timestampToOffset(submitABDto.getEndDate(), timeZone);
        tableEndTime = tableEndTime.withHour(0).withMinute(0).withSecond(0).withNano(0);

        if (tableStartTime.isBefore(now.withHour(0).withMinute(0).withSecond(0).withNano(0))) {
            throw new RequestRejectedException(ErrorMessage.START_DATE_FUTURE);
        }

        if (tableStartTime.isAfter(tableEndTime)) {
            throw new RequestRejectedException(ErrorMessage.START_BEFORE_END);
        }

        if (campaignRepository.existsDateCollision(tableStartTime, tableEndTime, workspace.getId(), optionalChannelPool.get().getChannelId())) {
            throw new RequestRejectedException(ErrorMessage.DATE_OVERLAP);
        }

        // create and initialize ABTable
        Campaign campaign = new Campaign();

        Optional<ChannelWorkspace> optionalChannelWorkspace = channelWorkspaceRepository.findById(channelId);
        if (optionalChannelWorkspace.isEmpty()) {
            LOGGER.warn("ChannelWorkspace with ID {} not found", channelId);
            return null;
        }
        List<ExpectedRetargetDto> expectedRetargetDtos = getExpectedRetargetDtos(webUser, List.of(optionalChannelWorkspace.get()));

        campaign.setTitle(submitABDto.getTitle());
        campaign.setStatus(CompanyStatus.PENDING);
        campaign.setWorkspace(workspace);
        campaign.setCreatedAt(now);
        campaign.setCreatedBy(webUser);
        campaign.setCampaignType(CampaignType.BASIC);
        campaign.setChannel(
                channelRepository.findById(optionalChannelWorkspace.get().getChannelId())
                        .orElseThrow(() -> new NotFoundException(ErrorMessage.DATA_NOT_FOUND)));
        campaign.setStartDate(tableStartTime);
        campaign.setEndDate(tableEndTime);

        Double reducePercent = submitABDto.getAudiencePercent() / 100.0;

        long maxRetargeted = (long) Math.floor(expectedRetargetDtos.get(0).getExpectedRetarget() * reducePercent);
        campaign.setMaxRetargeted(maxRetargeted);
        campaign.setCampaignCreatives(new HashSet<>());

        // save ABTable for getting ID
        campaignRepository.save(campaign);

        // Обработка каждого сообщения и связывание его с ABTable
        for (SubmitMessageDto submitMessageDto : submitABDto.getMessages()) {
            CampaignCreative campaignCreative = processMessage(submitMessageDto, campaign);
            if (campaignCreative != null) {
                campaignCreative.setOrdinal(submitABDto.getMessages().indexOf(submitMessageDto));
                campaign.getCampaignCreatives().add(campaignCreative);
            }
        }

        // Получение сохраненного ABTable для проверки его существования
        Optional<Campaign> optionalABTable = campaignRepository.findById(campaign.getId());
        if (optionalABTable.isEmpty()) {
            throw new NotFoundException(ErrorMessage.DATA_NOT_FOUND);
        }

        // Создание и возврат DTO
        return createABTableDto(optionalABTable.get(), channelId);
    }

    /**
     * Обрабатывает одно сообщение, клонируя его, сохраняя и создавая ABMessage.
     *
     * @param submitMessageDto объект DTO, содержащий детали сообщения
     * @param campaign         ABTable для связывания с сообщением
     * @return ABMessage, связанный с ABTable, или null, если сообщение не найдено
     */
    private CampaignCreative processMessage(SubmitMessageDto submitMessageDto, Campaign campaign) {
        CampaignCreative campaignCreative = new CampaignCreative();
        campaignCreative.setCampaign(campaign);
        campaignCreative.setPercent(submitMessageDto.getPercent());

        Optional<Message> optionalMessage = messageRepository.findById(submitMessageDto.getMessageId());
        if (optionalMessage.isEmpty()) {
            return null;
        }

        // Клонирование сообщения для избежания изменений оригинала
        Message message = optionalMessage.get();
        message = message.clone();

        // Извлечение действий и медиа, затем очистка в сообщении
        Set<Action> actions = message.getActions();
        Set<Media> medias = message.getMedias();
        message.setActions(new HashSet<>());
        message.setMedias(new HashSet<>());

        message.setStatus(MessageStatus.ACTIVE);
        message = messageRepository.save(message);

        // Связывание действий с новым сообщением
        Message finalMessage = message; // Эффективно финальная переменная для использования в лямбда-выражении
        actions.forEach(action -> action.setObjectPool(finalMessage));
        medias.forEach(media -> media.setObjectPool(finalMessage));

        actionRepository.saveAll(actions);
        mediaRepository.saveAll(medias);
        // Установка сообщения в ABMessage
        campaignCreative.setMessage(message);

        abMessageRepository.save(campaignCreative);

        return campaignCreative;
    }

    /**
     * Создает ABTableDto из сущности ABTable.
     *
     * @param campaign сущность ABTable
     * @return ABTableDto с подробностями ABTable
     */
    private CampaignDto createABTableDto(Campaign campaign, UUID channelId) {
        CampaignDto abTableDto = new CampaignDto();
        abTableDto.setId(campaign.getId());
        abTableDto.setChannelId(channelId);
        abTableDto.setTitle(campaign.getTitle());
        abTableDto.setStartDate(campaign.getStartDate().toEpochSecond());
        abTableDto.setStatus(campaign.getStatus());
        abTableDto.setEndDate(campaign.getEndDate().toEpochSecond());
        abTableDto.setCreatedAt(campaign.getCreatedAt().toEpochSecond());
        abTableDto.setCreatedBy(campaign.getCreatedBy().getUsername());
        abTableDto.setChannelTitle(campaign.getChannel().getTitle());
        abTableDto.setIsArchived(campaign.getIsArchived());
        abTableDto.setCampaignCreativeDto(campaign.getCampaignCreatives().stream()
                .map(this::createABMessageDto)
                .collect(Collectors.toList()));
        return abTableDto;
    }

    /**
     * Создает ABMessageDto из сущности ABMessage.
     *
     * @param campaignCreative сущность ABMessage
     * @return ABMessageDto с подробностями ABMessage
     */
    private CampaignCreativeDto createABMessageDto(CampaignCreative campaignCreative) {
        CampaignCreativeDto campaignCreativeDto = new CampaignCreativeDto();
        campaignCreativeDto.setPercent(campaignCreative.getPercent());
        campaignCreativeDto.setAbTableId(campaignCreative.getCampaign().getId());
        campaignCreativeDto.setText(campaignCreative.getMessage().getText());
        campaignCreativeDto.setMessageId(campaignCreative.getMessage().getId());
        return campaignCreativeDto;
    }
}
